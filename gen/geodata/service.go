// Code generated by goa v3.1.1, DO NOT EDIT.
//
// geodata service
//
// Command:
// $ goa gen jpmenezes.com/idebo/design

package geodata

import (
	"context"

	geodataviews "jpmenezes.com/idebo/gen/geodata/views"
)

// The geodata service makes it possible to add geodata.
type Service interface {
	// List all stored geodata
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	List(context.Context, *ListPayload) (res GeodataResultCollection, view string, err error)
	// Upload implements upload.
	Upload(context.Context, *FilesUpload) (res string, err error)
	// Remove geodata
	Remove(context.Context, *RemovePayload) (err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "geodata"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [3]string{"list", "upload", "remove"}

// ListPayload is the payload type of the geodata service list method.
type ListPayload struct {
	// Authentication header
	Authentication *string
}

// GeodataResultCollection is the result type of the geodata service list
// method.
type GeodataResultCollection []*GeodataResult

// FilesUpload is the payload type of the geodata service upload method.
type FilesUpload struct {
	// Collection of uploaded files
	Files []*FileUpload
}

// RemovePayload is the payload type of the geodata service remove method.
type RemovePayload struct {
	// ID of geodata to remove
	ID string
}

// GeodataResult describes a geodata file retrieved by the geodata service.
type GeodataResult struct {
	// ID is the unique id of the geodata file.
	ID uint
	// Name of geodata file
	Name string
	// Entity to which the geodata file belongs
	Entity     string
	Entityname *string
}

// A single File Upload type
type FileUpload struct {
	Type  *string
	Bytes []byte
	Name  *string
}

// NotFound is the type returned when attempting to show or delete a viewer
// that does not exist.
type NotFound struct {
	// Message of error
	Message string
	// ID of missing viewer
	ID string
}

// Error returns an error description.
func (e *NotFound) Error() string {
	return "NotFound is the type returned when attempting to show or delete a viewer that does not exist."
}

// ErrorName returns "NotFound".
func (e *NotFound) ErrorName() string {
	return e.Message
}

// NewGeodataResultCollection initializes result type GeodataResultCollection
// from viewed result type GeodataResultCollection.
func NewGeodataResultCollection(vres geodataviews.GeodataResultCollection) GeodataResultCollection {
	var res GeodataResultCollection
	switch vres.View {
	case "default", "":
		res = newGeodataResultCollection(vres.Projected)
	case "tiny":
		res = newGeodataResultCollectionTiny(vres.Projected)
	}
	return res
}

// NewViewedGeodataResultCollection initializes viewed result type
// GeodataResultCollection from result type GeodataResultCollection using the
// given view.
func NewViewedGeodataResultCollection(res GeodataResultCollection, view string) geodataviews.GeodataResultCollection {
	var vres geodataviews.GeodataResultCollection
	switch view {
	case "default", "":
		p := newGeodataResultCollectionView(res)
		vres = geodataviews.GeodataResultCollection{Projected: p, View: "default"}
	case "tiny":
		p := newGeodataResultCollectionViewTiny(res)
		vres = geodataviews.GeodataResultCollection{Projected: p, View: "tiny"}
	}
	return vres
}

// newGeodataResultCollection converts projected type GeodataResultCollection
// to service type GeodataResultCollection.
func newGeodataResultCollection(vres geodataviews.GeodataResultCollectionView) GeodataResultCollection {
	res := make(GeodataResultCollection, len(vres))
	for i, n := range vres {
		res[i] = newGeodataResult(n)
	}
	return res
}

// newGeodataResultCollectionTiny converts projected type
// GeodataResultCollection to service type GeodataResultCollection.
func newGeodataResultCollectionTiny(vres geodataviews.GeodataResultCollectionView) GeodataResultCollection {
	res := make(GeodataResultCollection, len(vres))
	for i, n := range vres {
		res[i] = newGeodataResultTiny(n)
	}
	return res
}

// newGeodataResultCollectionView projects result type GeodataResultCollection
// to projected type GeodataResultCollectionView using the "default" view.
func newGeodataResultCollectionView(res GeodataResultCollection) geodataviews.GeodataResultCollectionView {
	vres := make(geodataviews.GeodataResultCollectionView, len(res))
	for i, n := range res {
		vres[i] = newGeodataResultView(n)
	}
	return vres
}

// newGeodataResultCollectionViewTiny projects result type
// GeodataResultCollection to projected type GeodataResultCollectionView using
// the "tiny" view.
func newGeodataResultCollectionViewTiny(res GeodataResultCollection) geodataviews.GeodataResultCollectionView {
	vres := make(geodataviews.GeodataResultCollectionView, len(res))
	for i, n := range res {
		vres[i] = newGeodataResultViewTiny(n)
	}
	return vres
}

// newGeodataResult converts projected type GeodataResult to service type
// GeodataResult.
func newGeodataResult(vres *geodataviews.GeodataResultView) *GeodataResult {
	res := &GeodataResult{
		Entityname: vres.Entityname,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Entity != nil {
		res.Entity = *vres.Entity
	}
	return res
}

// newGeodataResultTiny converts projected type GeodataResult to service type
// GeodataResult.
func newGeodataResultTiny(vres *geodataviews.GeodataResultView) *GeodataResult {
	res := &GeodataResult{
		Entityname: vres.Entityname,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Entity != nil {
		res.Entity = *vres.Entity
	}
	return res
}

// newGeodataResultView projects result type GeodataResult to projected type
// GeodataResultView using the "default" view.
func newGeodataResultView(res *GeodataResult) *geodataviews.GeodataResultView {
	vres := &geodataviews.GeodataResultView{
		ID:         &res.ID,
		Name:       &res.Name,
		Entity:     &res.Entity,
		Entityname: res.Entityname,
	}
	return vres
}

// newGeodataResultViewTiny projects result type GeodataResult to projected
// type GeodataResultView using the "tiny" view.
func newGeodataResultViewTiny(res *GeodataResult) *geodataviews.GeodataResultView {
	vres := &geodataviews.GeodataResultView{
		ID:         &res.ID,
		Name:       &res.Name,
		Entity:     &res.Entity,
		Entityname: res.Entityname,
	}
	return vres
}
